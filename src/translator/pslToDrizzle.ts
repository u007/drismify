// src/translator/pslToDrizzle.ts

// Helper function to convert PascalCase to snake_case (e.g., UserProfile -> user_profile)
function pascalToSnakeCase(str: string): string {
  return str
    .replace(/(?:^|\.?)([A-Z])/g, (_match, char) => `_${char.toLowerCase()}`)
    .replace(/^_/, '');
}

// Helper function to convert PascalCase to camelCase (e.g., UserProfile -> userProfile)
function pascalToCamelCase(str: string): string {
  if (!str) return '';
  return str.charAt(0).toLowerCase() + str.slice(1);
}

interface PslAttributeAst {
  name: string;
  args: any;
}

interface PslFieldAst {
  name: string;
  type: {
    name: string;
    optional: boolean;
    isArray: boolean;
  };
  attributes: PslAttributeAst[];
}

interface PslModelAst {
  type: 'model';
  name: string; // PascalCase
  fields: PslFieldAst[];
  attributes: PslAttributeAst[]; // Model-level attributes like @@index, @@unique
}

interface PslEnumAst {
  type: 'enum';
  name: string; // PascalCase
  values: string[];
}

interface PslTypeAst {
  type: 'type';
  name: string; // PascalCase
  fields: PslFieldAst[];
}

interface PslViewAst {
  type: 'view';
  name: string; // PascalCase
  fields: PslFieldAst[];
  attributes: PslAttributeAst[]; // View-level attributes like @@unique, @@id
}

interface PslDatasourceAst {
  type: 'datasource';
  name: string;
  assignments: Record<string, string>;
}

interface PslGeneratorAst {
  type: 'generator';
  name: string;
  assignments: Record<string, string>;
}

// Union type for all PSL AST node types
type PslAstNode =
  | PslModelAst
  | PslEnumAst
  | PslTypeAst
  | PslViewAst
  | PslDatasourceAst
  | PslGeneratorAst;

export function translatePslToDrizzleSchema(pslAst: PslAstNode[]): string {
  let output = "// Generated by Drismify - Do not edit manually\n\n";
  const imports = new Set<string>();
  imports.add("import { sqliteTable } from 'drizzle-orm/sqlite-core';"); // Default import
  imports.add("import { text } from 'drizzle-orm/sqlite-core';"); // Likely needed for enums

  const enumTypeDefinitions: string[] = [];
  const enumAsts = pslAst.filter(node => node.type === 'enum') as PslEnumAst[];
  const knownEnumNames = new Set(enumAsts.map(e => e.name));

  for (const enumDef of enumAsts) {
    const enumNamePascal = enumDef.name;
    const valuesString = enumDef.values.map(v => `'${v}'`).join(' | ');
    enumTypeDefinitions.push(`export type ${enumNamePascal} = ${valuesString};\n`);
  }

  // Process composite types
  const typeDefinitions: string[] = [];
  const typeAsts = pslAst.filter(node => node.type === 'type') as PslTypeAst[];

  for (const typeDef of typeAsts) {
    const typeNamePascal = typeDef.name;
    const fieldsString = typeDef.fields.map(field => {
      const fieldType = field.type.optional ? `${field.type.name}?` : field.type.name;
      return `  ${field.name}: ${fieldType};`;
    }).join('\n');

    typeDefinitions.push(`export type ${typeNamePascal} = {\n${fieldsString}\n};\n`);
  }

  const tableDefinitions: string[] = [];
  const indexDefinitions: string[] = [];
  const modelAsts = pslAst.filter(node => node.type === 'model') as PslModelAst[];

  for (const model of modelAsts) {
    const modelNamePascal = model.name;
    const constNameCamel = pascalToCamelCase(modelNamePascal); // e.g., user, postOffice
    const tableNameSnake = pascalToSnakeCase(modelNamePascal); // e.g., user, post_office

    // --- Pass 1: Collect Foreign Key Info from @relation attributes ---
    const foreignKeyData = new Map<string, { referencedTableConst: string, referencedField: string, optionsString: string }>();
    for (const field of model.fields) {
      for (const attr of field.attributes) {
        if (attr.name === 'relation' && attr.args && Array.isArray(attr.args.fields) && attr.args.fields.length > 0 &&
            attr.args.references && Array.isArray(attr.args.references) && attr.args.references.length > 0) {

          const pslRelationArgs = attr.args;
          const relatedModelPascalName = field.type.name; // Type of the field holding @relation, e.g., "User"
          const referencedTableConst = pascalToCamelCase(relatedModelPascalName);
          const referencedField = pslRelationArgs.references[0]; // Assuming single field for now

          const drizzleRelationActions: { onDelete?: string; onUpdate?: string } = {};
          if (pslRelationArgs.onDelete) {
            drizzleRelationActions.onDelete = pslRelationArgs.onDelete.toLowerCase().replace('_', ' ');
          }
          if (pslRelationArgs.onUpdate) {
            drizzleRelationActions.onUpdate = pslRelationArgs.onUpdate.toLowerCase().replace('_', ' ');
          }

          let optionsString = "";
          if (Object.keys(drizzleRelationActions).length > 0) {
            const optionsParts = Object.entries(drizzleRelationActions)
              .map(([key, value]) => `${key}: '${value}'`)
              .join(', ');
            optionsString = `, { ${optionsParts} }`;
          }

          // Store this info for each field listed in `pslRelationArgs.fields`
          for (const fkFieldName of pslRelationArgs.fields) {
            foreignKeyData.set(fkFieldName, { referencedTableConst, referencedField, optionsString });
          }
        }
      }
    }

    // --- Pass 2: Build Column Definitions ---
    const columnDefinitions: string[] = [];
    for (const field of model.fields) {
      // Skip relation scalar fields for now (e.g. posts Post[]), they are handled by relations object
      // or complex types like Json[] etc. Only handle direct column types.
      if (field.type.isArray && !model.fields.find(f => f.name === `${field.name}Id` || field.attributes.some(attr => attr.name === 'relation'))) {
        // Basic scalar list like String[] - not directly mappable to a single SQL column easily without JSON/TEXT.
        // For now, we can comment it out or skip.
        columnDefinitions.push(`  // Field '${field.name}' of type '${field.type.name}[]' is a scalar list and needs special handling (e.g., JSON) or is a relation.`);
        continue;
      }
      if (field.type.isArray) { // Relation arrays like Post[] are not columns
        continue;
      }

      const columnNameSnake = pascalToSnakeCase(field.name);
      let columnType = '';
      let columnBuilder = '';

      switch (field.type.name) {
        case 'String':
          imports.add("import { text } from 'drizzle-orm/sqlite-core';");
          columnType = `text('${columnNameSnake}')`;
          break;
        case 'Int':
          imports.add("import { integer } from 'drizzle-orm/sqlite-core';");
          columnType = `integer('${columnNameSnake}')`;
          break;
        case 'Boolean':
          imports.add("import { integer } from 'drizzle-orm/sqlite-core';");
          columnType = `integer('${columnNameSnake}', { mode: 'boolean' })`;
          break;
        case 'DateTime':
          imports.add("import { integer } from 'drizzle-orm/sqlite-core';");
          // Storing as Unix timestamp (integer) for SQLite. Or text for ISO string.
          columnType = `integer('${columnNameSnake}', { mode: 'timestamp' })`;
          break;
        case 'Float':
          imports.add("import { real } from 'drizzle-orm/sqlite-core';");
          columnType = `real('${columnNameSnake}')`;
          break;
        case 'Json':
          imports.add("import { text } from 'drizzle-orm/sqlite-core';");
          columnType = `text('${columnNameSnake}', { mode: 'json' })`; // Drizzle specific mode for JSON
          break;
        case 'Bytes':
          imports.add("import { blob } from 'drizzle-orm/sqlite-core';");
          columnType = `blob('${columnNameSnake}')`;
          break;
        // default:
        //   columnType = `text('${columnNameSnake}')`; // Fallback for unknown Prisma types
        //   columnDefinitions.push(`  // Unknown Prisma type '${field.type.name}' for field '${field.name}', using text.`);
        default: {
          if (knownEnumNames.has(field.type.name)) {
            // This field uses a defined enum type
            columnType = `text('${columnNameSnake}').$type<${field.type.name}>()`;
          } else {
            // If type is another model name (potential relation scalar field like authorId)
            // For now, if it's not a known scalar or enum, skip direct column generation.
            // Relation scalar fields (like authorId for author User) will be handled by @relation attribute processing.
            const isLikelyRelationScalar = modelAsts.some(m => m.name === field.type.name);
            if (!isLikelyRelationScalar) {
               columnDefinitions.push(`  // Field '${field.name}' with complex/unknown type '${field.type.name}' - will be handled by attributes or specific type mappers.`);
            }
            continue; // Skip if not a recognized primitive or enum for direct column mapping yet
          }
          break; // Break from switch if enum handled
        }
      }

      columnBuilder = `  ${field.name}: ${columnType}`;

      let isPk = false;
      let isAutoIncrement = false;

      // Apply attributes
      for (const attr of field.attributes) {
        if (attr.name === 'id') {
          isPk = true;
        } else if (attr.name === 'default' && attr.args && typeof attr.args === 'object' && attr.args.type === 'function' && attr.args.name === 'autoincrement') {
          isAutoIncrement = true;
        } else if (attr.name === 'unique') {
          columnBuilder += '.unique()';
        } else if (attr.name === 'updatedAt' && field.type.name === 'DateTime') {
          columnBuilder += '.$onUpdate(() => new Date())';
        } else if (attr.name === 'default') {
          imports.add("import { sql } from 'drizzle-orm';");
          if (attr.args && typeof attr.args === 'object' && attr.args.type === 'function') {
            if (attr.args.name === 'now') columnBuilder += '.default(sql`(CURRENT_TIMESTAMP)`)';
            else if (attr.args.name === 'uuid') columnBuilder += '.default(sql`(uuid())`)';
            else if (attr.args.name === 'cuid') columnBuilder += '.default(sql`(cuid())`)';
            // autoincrement is handled by primaryKey logic
          } else if (typeof attr.args === 'string') {
            columnBuilder += `.default("${attr.args.replace(/"/g, '\\"')}")`;
          } else if (typeof attr.args === 'boolean' || typeof attr.args === 'number') {
            columnBuilder += `.default(${attr.args})`;
          }
        }
        // @relation attribute itself doesn't add a modifier here; its info is used by foreignKeyData
      }

      // Apply FK constraint if this field is an FK
      if (foreignKeyData.has(field.name)) {
        const fkInfo = foreignKeyData.get(field.name);
        if (fkInfo) { // Explicit check to satisfy linter
          columnBuilder += `.references(() => ${fkInfo.referencedTableConst}.${fkInfo.referencedField}${fkInfo.optionsString})`;
        }
      }

      // Apply PK and notNull (after all other modifiers)
      if (isPk) {
        if (field.type.name === 'Int' && isAutoIncrement) {
          columnBuilder += '.primaryKey({ autoIncrement: true })'; // Simple string append
        } else {
          columnBuilder += '.primaryKey()'; // Simple string append
        }
      } else if (!field.type.optional) { // Add .notNull() if not PK and not optional
        columnBuilder += '.notNull()'; // Simple string append
      }

      columnDefinitions.push(`${columnBuilder},`);
    }

    // Remove trailing comma from the last column definition if any
    if (columnDefinitions.length > 0) {
      const lastCol = columnDefinitions[columnDefinitions.length - 1];
      if (lastCol.endsWith(',')) {
        columnDefinitions[columnDefinitions.length - 1] = lastCol.slice(0, -1);
      }
    }

    const columnsString = columnDefinitions.length > 0 ? columnDefinitions.join('\n') : "  // No direct columns defined for this model yet (check relations/enums)";

    // Process model-level attributes (@@index, @@unique, etc.)
    if (model.attributes && model.attributes.length > 0) {
      imports.add("import { index, uniqueIndex } from 'drizzle-orm/sqlite-core';");

      for (const attr of model.attributes) {
        if (attr.name === 'index' && attr.args && attr.args.fields && Array.isArray(attr.args.fields)) {
          const indexName = attr.args.name ? `'${attr.args.name}'` : `'idx_${tableNameSnake}_${attr.args.fields.join('_')}'`;
          const fieldsArray = attr.args.fields.map((f: string) => `${constNameCamel}.${f}`).join(', ');

          indexDefinitions.push(
            `export const ${constNameCamel}${pascalToCamelCase(attr.args.name || `Idx${attr.args.fields.join('')}`)} = index(${indexName}, [${fieldsArray}]);\n`
          );
        } else if (attr.name === 'unique' && attr.args && attr.args.fields && Array.isArray(attr.args.fields)) {
          const indexName = attr.args.name ? `'${attr.args.name}'` : `'unique_${tableNameSnake}_${attr.args.fields.join('_')}'`;
          const fieldsArray = attr.args.fields.map((f: string) => `${constNameCamel}.${f}`).join(', ');

          indexDefinitions.push(
            `export const ${constNameCamel}${pascalToCamelCase(attr.args.name || `Unique${attr.args.fields.join('')}`)} = uniqueIndex(${indexName}, [${fieldsArray}]);\n`
          );
        }
      }
    }

    tableDefinitions.push(
      `export const ${constNameCamel} = sqliteTable('${tableNameSnake}', {\n${columnsString}\n});\n`
    );
  }

  const relationsDefinitions: string[] = [];
  if (modelAsts.length > 0) {
    imports.add("import { relations } from 'drizzle-orm';");
  }

  for (const model of modelAsts) {
    const modelNamePascal = model.name;
    const constNameCamel = pascalToCamelCase(modelNamePascal); // Drizzle table const name

    const relationFields: string[] = [];

    for (const field of model.fields) {
      const isRelationField = field.attributes.some(attr => attr.name === 'relation') ||
                              (field.type.isArray && modelAsts.some(m => m.name === field.type.name));

      if (!isRelationField) continue;

      const relatedModelNamePascal = field.type.name;
      const relatedTableConstName = pascalToCamelCase(relatedModelNamePascal);
      const relationName = field.name; // e.g., 'author' or 'posts'

      if (field.type.isArray) { // One-to-many or Many-to-many (many-to-many needs explicit join table in Prisma)
        // Assuming one-to-many for now if it's an array of another model type
        // Prisma: model User { posts Post[] } -> Drizzle: posts: many(post)
        relationFields.push(`  ${relationName}: many(${relatedTableConstName})`);
      } else {
        // One-to-one or Many-to-one
        // Prisma: model Post { author User @relation(fields: [authorId], references: [id]) }
        // Drizzle: author: one(user, { fields: [post.authorId], references: [user.id] })
        const relationAttr = field.attributes.find(attr => attr.name === 'relation');
        if (relationAttr?.args) { // Using optional chaining
          const pslRelationArgs = relationAttr.args; // This is our structured object
          if (pslRelationArgs?.fields && pslRelationArgs?.references &&
              Array.isArray(pslRelationArgs.fields) && pslRelationArgs.fields.length > 0 &&
              Array.isArray(pslRelationArgs.references) && pslRelationArgs.references.length > 0) {

            const localFields = pslRelationArgs.fields.map((f: string) => `${constNameCamel}.${f}`).join(', ');
            const foreignFields = pslRelationArgs.references.map((f: string) => `${relatedTableConstName}.${f}`).join(', ');

            relationFields.push(`  ${relationName}: one(${relatedTableConstName}, {\n    fields: [${localFields}],\n    references: [${foreignFields}]\n  })`);
          } else {
            // Relation attribute without fields/references (e.g. implicit one-to-one back-relation)
            // Drizzle might infer this or it might need a simpler one() call.
            // For now, if fields/references are missing, we might skip or make a simpler 'one' call.
            // This case needs more detailed handling for implicit relations if they are to be fully supported.
            // For an explicit @relation, fields & references are typical.
             relationFields.push(`  ${relationName}: one(${relatedTableConstName}) // Check if fields/references are needed or inferred`);
          }
        } else {
           // Field type is another model, but no @relation attribute (implicit relation?)
           // This is less common in Prisma for explicit relations but could occur.
           // Drizzle's 'one' usually needs fields/references for clarity.
           relationFields.push(`  ${relationName}: one(${relatedTableConstName}) // Implicit relation, may need fields/references`);
        }
      }
    }

    if (relationFields.length > 0) {
      relationsDefinitions.push(
        `export const ${constNameCamel}Relations = relations(${constNameCamel}, ({ one, many }) => ({\n${relationFields.join(',\n')}\n}));\n`
      );
    }
  }

  output += `${Array.from(imports).join('\n')}\n\n`;

  // Add enum type definitions
  if (enumTypeDefinitions.length > 0) {
    output += `${enumTypeDefinitions.join('\n')}\n`;
  }

  // Add composite type definitions
  if (typeDefinitions.length > 0) {
    output += `${typeDefinitions.join('\n')}\n`;
  }

  // Add table definitions
  output += tableDefinitions.join('\n');

  // Add index definitions
  if (indexDefinitions.length > 0) {
    output += `\n${indexDefinitions.join('\n')}`;
  }

  // Add relation definitions
  if (relationsDefinitions.length > 0) {
    output += `\n${relationsDefinitions.join('\n')}`;
  }

  return output;
}
