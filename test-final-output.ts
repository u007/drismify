// Generated by Drismify - Do not edit manually

import { sqliteTable } from 'drizzle-orm/sqlite-core';
import { text } from 'drizzle-orm/sqlite-core';
import { integer } from 'drizzle-orm/sqlite-core';
import { sql } from 'drizzle-orm';
import { index, uniqueIndex, check } from 'drizzle-orm/sqlite-core';
import { relations } from 'drizzle-orm';

export type Role = 'USER' | 'ADMIN' | 'MODERATOR';

export type PostStatus = 'DRAFT' | 'PUBLISHED' | 'ARCHIVED';

export type Address = {
  street: string;
  city: string;
  state: string;
  zip: string;
  country: string;
};

export const user = sqliteTable('user', {
  id: integer('id').primaryKey(),
  email: text('email').unique().notNull(),
  name: text('name'),
  role: text('role').$type<Role>().default("USER").notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).$onUpdate(() => new Date()).notNull(),
  // Field 'posts' of type 'Post[]' is a scalar list and needs special handling (e.g., JSON) or is a relation.
  // Field 'comments' of type 'Comment[]' is a scalar list and needs special handling (e.g., JSON) or is a relation.
});

export const profile = sqliteTable('profile', {
  id: integer('id').primaryKey(),
  bio: text('bio'),
  avatar: text('avatar'),
  userId: integer('user_id').unique().references(() => user.id).notNull()
});

export const post = sqliteTable('post', {
  id: integer('id').primaryKey(),
  title: text('title').notNull(),
  content: text('content').notNull(),
  published: integer('published', { mode: 'boolean' }).notNull(),
  status: text('status').$type<PostStatus>().default("DRAFT").notNull(),
  authorId: integer('author_id').references(() => user.id).notNull(),
  // Field 'comments' of type 'Comment[]' is a scalar list and needs special handling (e.g., JSON) or is a relation.
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
  updatedAt: integer('updated_at', { mode: 'timestamp' }).$onUpdate(() => new Date()).notNull()
});

export const comment = sqliteTable('comment', {
  id: integer('id').primaryKey(),
  content: text('content').notNull(),
  postId: integer('post_id').references(() => post.id).notNull(),
  authorId: integer('author_id').references(() => user.id).notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull()
});

export const tag = sqliteTable('tag', {
  id: integer('id').primaryKey(),
  name: text('name').unique().notNull()
});

export const useridxnameemail = index('idx_user_name_email', [user.name, user.email]);

export const postidxauthorId = index('idx_post_authorId', [post.authorId]);

export const postuniquetitleauthorId = uniqueIndex('unique_post_title_authorId', [post.title, post.authorId]);

export const commentidxpostIdauthorId = index('idx_comment_postId_authorId', [comment.postId, comment.authorId]);

export const userRelations = relations(user, ({ one, many }) => ({
  posts: many(post),
  comments: many(comment)
}));

export const profileRelations = relations(profile, ({ one, many }) => ({
  user: one(user, {
    fields: [profile.userId],
    references: [user.id]
  })
}));

export const postRelations = relations(post, ({ one, many }) => ({
  author: one(user, {
    fields: [post.authorId],
    references: [user.id]
  }),
  comments: many(comment),
  tags: many(tag)
}));

export const commentRelations = relations(comment, ({ one, many }) => ({
  post: one(post, {
    fields: [comment.postId],
    references: [post.id]
  }),
  author: one(user, {
    fields: [comment.authorId],
    references: [user.id]
  })
}));

export const tagRelations = relations(tag, ({ one, many }) => ({
  posts: many(post)
}));
